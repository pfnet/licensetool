#!/usr/bin/env node

const fs = require("fs");
const util = require("util");
const licenseChecker = require("license-checker-rseidelsohn");
const spdxExpressionParse = require("spdx-expression-parse");
const spdxLicenseList = require("spdx-license-list");

function strcmp(s1, s2) {
  if (s1 < s2) {
    return -1;
  }
  if (s1 === s2) {
    return 0;
  }
  return 1;
}

class PackageProcessError extends Error {
  constructor({ message, detail }) {
    super();
    this.message = message;
    this.detail = detail;
  }
}

class LicenseMap {
  constructor() {
    this.data = [];
  }

  static fromLicenseCheckerResult(licenseData, { onsuccess, onerror }) {
    const map = new LicenseMap();
    const errors = [];
    for (const [packageName, info] of Object.entries(licenseData)) {
      try {
        map.#addPackageByLicenseCheckerResult({ packageName, info });
      } catch (e) {
        if (e instanceof PackageProcessError) {
          errors.push(e);
        } else {
          throw e;
        }
      }
    }
    if (errors.length > 0) {
      onerror(errors);
    } else {
      onsuccess(map);
    }
  }

  #addPackageByLicenseCheckerResult({ packageName, info }) {
    const isGuessed = info.licenses.endsWith("*");
    if (isGuessed) {
      throw new PackageProcessError({
        message:
          'License information is only guessed by license-checker-rseidelsohn, which may not be accurate. You need to specify the license manually.',
        detail: {
          packageName,
          licenseInfo: info,
        },
      });
    }
    const licensesParsed = (() => {
      try {
        return spdxExpressionParse(info.licenses);
      } catch (e) {
        throw new PackageProcessError({
          message: "Non-standard SPDX license expression. Check `licenseInfo.licenses`.",
          detail: {
            packageName,
            licenseInfo: info,
          },
        });
      }
    })();
    if (licensesParsed.license === undefined) {
      throw new PackageProcessError({
        message:
          "License is composite and cannot be resolved automatically. You need to specify the license manually.",
        detail: {
          packageName,
          licenseInfo: info,
          licenses: licensesParsed,
        },
      });
    }
    const licenseName = info.licenses;
    const licenseContent = (() => {
      // Retrieve the license file path. If it's a README file, we don't use it.
      const licenseFile =
        info.licenseFile === undefined
          ? undefined
          : /[^/]*README[^/]*$/.test(info.licenseFile)
          ? undefined
          : info.licenseFile;
      // License file content, if any.
      if (licenseFile !== undefined) {
        return fs.readFileSync(info.licenseFile).toString();
      }
      // Fall back to spdx-license-list.
      if (spdxLicenseList[licenseName] !== undefined) {
        return spdxLicenseList[licenseName];
      }
      throw new PackageProcessError({
        message:
          "License text could not retrieved. You may need to specify the license manually.",
        detail: {
          packageName,
          licenseInfo: info,
        },
      });
    })();
    this.addPackage({
      packageName,
      licenseName,
      licenseContent,
    });
  }

  addPackage({ packageName, licenseName, licenseContent }) {
    const data = this.data;
    let entry = data.find(
      (localEntry) =>
        localEntry.licenseName === licenseName &&
        localEntry.licenseContent === licenseContent
    );
    if (!entry) {
      entry = { licenseName, licenseContent, packageNames: [] };
      data.push(entry);
    }
    entry.packageNames.push(packageName);
  }

  format() {
    const buf = [];
    const data = this.data;
    data.sort((entry1, entry2) =>
      strcmp(entry1.licenseName, entry2.licenseName)
    );
    for (const entry of data) {
      entry.packageNames.sort(strcmp);
      buf.push("-----------------------------------------");
      buf.push("License notices for packages:");
      for (const packageName of entry.packageNames) {
        buf.push("  " + packageName);
      }
      buf.push("");
      buf.push("=".repeat(entry.licenseName.length + 1));
      buf.push(entry.licenseName);
      buf.push("=".repeat(entry.licenseName.length + 1));
      buf.push("");
      buf.push(entry.licenseContent);
      buf.push("");
    }

    return buf.join("\n");
  }
}

licenseChecker.init(
  {
    start: ".",
    production: true,
    excludePrivatePackages: true,
  },
  (inputError, result) => {
    if (inputError) {
      console.error(inputError);
      process.exit(1);
    }
    LicenseMap.fromLicenseCheckerResult(result, {
      onsuccess: (map) => {
        console.log(map.format());
      },
      onerror: (errors) => {
        console.error(`${errors.length} errors are found.`);
        for (const error of errors) {
          console.error(
            util.inspect(
              {
                error: error.message,
                detail: error.detail,
              },
              { depth: null, colors: true }
            )
          );
        }
      },
    });
  }
);
